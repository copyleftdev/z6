#!/bin/bash
#
# Z6 Pre-Commit Hook - Tiger Style Enforcement
#
# This hook enforces Tiger Style philosophy:
# - Code formatting
# - Test execution
# - Assertion density
# - Bounded loops
# - Explicit error handling
#
# Install: ./scripts/install-hooks.sh

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "üêÖ Tiger Style Pre-Commit Hook"
echo "=============================="

# Track failures
FAILURES=0

# Get staged Zig files
STAGED_ZIG_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.zig$' || true)

if [ -z "$STAGED_ZIG_FILES" ]; then
    echo "No Zig files staged, skipping checks"
    exit 0
fi

echo ""
echo "Checking ${STAGED_ZIG_FILES//$'\n'/, }"
echo ""

# ============================================================================
# 1. Code Formatting Check
# ============================================================================
echo "‚Üí Checking code formatting..."

if ! zig fmt --check $STAGED_ZIG_FILES 2>/dev/null; then
    echo -e "${RED}‚úó Code not formatted${NC}"
    echo ""
    echo "Run: zig fmt src/ tests/"
    echo ""
    FAILURES=$((FAILURES + 1))
else
    echo -e "${GREEN}‚úì Code formatted correctly${NC}"
fi

# ============================================================================
# 2. Assertion Density Check
# ============================================================================
echo ""
echo "‚Üí Checking assertion density (min 2 per function)..."

ASSERTION_FAILURES=0

for file in $STAGED_ZIG_FILES; do
    # Skip test files (they have different requirements)
    if [[ $file == *"test"* ]]; then
        continue
    fi
    
    # Count functions and assertions
    FUNCTION_COUNT=$(grep -c '^[[:space:]]*\(pub \)\?fn ' "$file" || echo 0)
    ASSERT_COUNT=$(grep -c 'assert(' "$file" || echo 0)
    
    if [ "$FUNCTION_COUNT" -gt 0 ]; then
        REQUIRED_ASSERTIONS=$((FUNCTION_COUNT * 2))
        
        if [ "$ASSERT_COUNT" -lt "$REQUIRED_ASSERTIONS" ]; then
            echo -e "${RED}‚úó $file: $ASSERT_COUNT assertions for $FUNCTION_COUNT functions (need $REQUIRED_ASSERTIONS)${NC}"
            ASSERTION_FAILURES=$((ASSERTION_FAILURES + 1))
        fi
    fi
done

if [ "$ASSERTION_FAILURES" -eq 0 ]; then
    echo -e "${GREEN}‚úì Assertion density satisfied${NC}"
else
    echo -e "${RED}‚úó Insufficient assertions in $ASSERTION_FAILURES file(s)${NC}"
    echo ""
    echo "Tiger Style requires minimum 2 assertions per function"
    echo ""
    FAILURES=$((FAILURES + 1))
fi

# ============================================================================
# 3. Bounded Loops Check
# ============================================================================
echo ""
echo "‚Üí Checking for unbounded loops..."

UNBOUNDED_LOOPS=0

for file in $STAGED_ZIG_FILES; do
    # Look for while (true) or while without clear bound
    if grep -n 'while (true)' "$file" >/dev/null 2>&1; then
        LINES=$(grep -n 'while (true)' "$file" | cut -d: -f1)
        
        # Check if there's an assert after the loop (event loop pattern)
        for line in $LINES; do
            # Check next 5 lines for assert or unreachable
            NEXT_LINES=$(sed -n "$((line+1)),$((line+5))p" "$file")
            
            if ! echo "$NEXT_LINES" | grep -E '(assert|unreachable|@panic)' >/dev/null; then
                echo -e "${RED}‚úó $file:$line: unbounded while(true) without assertion${NC}"
                UNBOUNDED_LOOPS=$((UNBOUNDED_LOOPS + 1))
            fi
        done
    fi
done

if [ "$UNBOUNDED_LOOPS" -eq 0 ]; then
    echo -e "${GREEN}‚úì All loops bounded or explicitly marked${NC}"
else
    echo -e "${RED}‚úó Found $UNBOUNDED_LOOPS unbounded loop(s)${NC}"
    echo ""
    echo "All loops must be bounded or followed by assert/unreachable"
    echo ""
    FAILURES=$((FAILURES + 1))
fi

# ============================================================================
# 4. Explicit Error Handling Check
# ============================================================================
echo ""
echo "‚Üí Checking for explicit error handling..."

SILENT_FAILURES=0

for file in $STAGED_ZIG_FILES; do
    # Look for optional returns without error handling
    if grep -n 'return null;' "$file" >/dev/null 2>&1; then
        echo -e "${YELLOW}‚ö† $file: contains 'return null' (prefer explicit errors)${NC}"
        # This is a warning, not a failure
    fi
    
    # Look for catch without handling
    if grep -n 'catch {}' "$file" >/dev/null 2>&1; then
        LINES=$(grep -n 'catch {}' "$file" | cut -d: -f1 | tr '\n' ',')
        echo -e "${RED}‚úó $file:$LINES: silent error suppression (catch {})${NC}"
        SILENT_FAILURES=$((SILENT_FAILURES + 1))
    fi
done

if [ "$SILENT_FAILURES" -eq 0 ]; then
    echo -e "${GREEN}‚úì No silent error handling${NC}"
else
    echo -e "${RED}‚úó Found $SILENT_FAILURES silent error handler(s)${NC}"
    echo ""
    echo "Errors must be explicitly handled or propagated"
    echo ""
    FAILURES=$((FAILURES + 1))
fi

# ============================================================================
# 5. Build Check
# ============================================================================
echo ""
echo "‚Üí Building project..."

if zig build 2>&1 | tee /tmp/zig-build.log; then
    echo -e "${GREEN}‚úì Build successful${NC}"
else
    echo -e "${RED}‚úó Build failed${NC}"
    echo ""
    cat /tmp/zig-build.log
    echo ""
    FAILURES=$((FAILURES + 1))
fi

# ============================================================================
# 6. Unit Tests
# ============================================================================
echo ""
echo "‚Üí Running unit tests..."

if zig build test 2>&1 | tee /tmp/zig-test.log; then
    echo -e "${GREEN}‚úì All unit tests passed${NC}"
else
    echo -e "${RED}‚úó Tests failed${NC}"
    echo ""
    tail -20 /tmp/zig-test.log
    echo ""
    FAILURES=$((FAILURES + 1))
fi

# ============================================================================
# Summary
# ============================================================================
echo ""
echo "=============================="

if [ "$FAILURES" -eq 0 ]; then
    echo -e "${GREEN}‚úì All checks passed${NC}"
    echo ""
    echo "üêÖ Tiger Style approved"
    exit 0
else
    echo -e "${RED}‚úó $FAILURES check(s) failed${NC}"
    echo ""
    echo "Fix the issues above before committing"
    echo ""
    echo "To bypass (NOT RECOMMENDED):"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi
